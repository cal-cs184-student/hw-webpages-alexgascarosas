<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Names: Alex Gasca Rosas</div>

		<br>

		Link to webpage: <a href="https://cal-cs184-student.github.io/hw-webpages-alexgascarosas/hw1/index.html">Homework 1 Webpage (sp25)</a>
		
		<br>

		Link to GitHub repository: <a href="https://github.com/cal-cs184-student/hw-webpages-alexgascarosas">My Github</a>

		<!--
			<figure>
				<img src="lion.jpg" alt="Lion" style="width:50%"/>
				<figcaption>You can add images with captions!</figcaption>
			</figure>
		-->

		<h2>Overview</h2>
		<p>
        For homework 1 I built a software rasterizer pipeline for Scalable Vector Graphics (SVGs). I implemented...
		<ol>
			<li>a single-color triangle rasterization using edge functions,</li>
			<li>a supersampling antialiasing using a per-subsample buffer and resolve step,</li>
			<li>SVG transforms - translate/scale/rotate - in homogeneous coordinates,.</li>
			<li>barycentric coordinates for smooth interpolated vertex colors,</li>
			<li>texture mapping with nearest & bilinear pixel sampling, & </li>
			<li>a mipmapped level sampling - L_ZERO/L_NEAREST/L_LINEAR - including trilinear filtering.</li>
		</ol>
        <p>
        The most interesting takeaway was that everything is built from the same triangle backbone. It is cool and 
		interesting to see that everything in homework 1 was ultimatley made from multiple single triangles.
		</p>


		<h2>Task 1: Drawing Single-Color Triangles</h2> 

		<h3>Algorithm</h3>
      	<p>
			To rasterize a triangle, I first transformed its three vertices into screen space. Once I had the 2D coordinates, 
			I computed the triangle’s axis-aligned bounding box by taking the minimum and maximum x and y values among each vertex. 
			
			I then iterate over every pixel inside this bounding box. For each sample point, I determined whether it lies inside the 
			triangle using edge function. Each triangle edge defines a line, and the interior of the triangle is the intersection of
			the three corresponding half-planes. If the sample lies on the correct side of all three edges,  it is inside the triangle.
			
			For these samples inside the triangle, I finally computed barycentric coordinates to interpolate attributes such as color and depth.
		</p>

		<h3>Why algorithm is no worse than bounding-box sampling</h3>
		<p>
			The algorithm only checks samples inside the triangle’s bounding box. We let N be the number of samples inside the triangle's 
			bounding box. Since the algorithm examines only samples within this bounding box and performs a constant-time inside-triangle test for
			each sample, this would take constant time. Runtime is \(O(N)\). 
 
			This is no worse than an algorithm that checks every sample within the bounding box, since both approaches iterate over the same set 
			of candidate samples and perform constant work per sample.
		</p>


		<h3>Images</h3>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="hw1_1_full.png" width="500px"/>
				  <figcaption>Screenshot #1: basic/test4.svg</figcaption>
				  <figcaption>(default view, sample rate 1)</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
					<div style="display: flex; justify-content: center; gap: 20px;">
					<div>
						<img src="hw1_1_zoom.png" width="300px"/>
						<figcaption>Screenshot #2. Pixel inspector placed on left end of red triangle.</figcaption>
					</div>
					<div>
						<img src="hw1_1_zoom2.png" width="300px"/>
						<figcaption>Screenshot #3. Pixel inspector placed on right end of red triangle and top of purple triangle.</figcaption>
					</div>
					</div>
				</td>
			  </tr>
			</table>
		</div>

		<h3>Extra Credit</h3>

		<style>
			.styled-table {
				margin-left: auto;
				margin-right: auto;
				border-collapse: collapse;
				width: 60%;
				text-align: center;
			}
			.styled-table th, .styled-table td {
				border: 1px solid #ddd;
				padding: 8px;
			}
		</style>

		<table class="styled-table">
			<thead>
				<tr>
					<th></th>
					<th>Basic Optimization times (ms)</th>
					<th>Special Optimization times (ms)</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<th>1</th>
					<th>0.6349</th>
					<th>0.4391</th>
				</tr>
				<tr>
					<th>2</th>
					<th>0.6156</th>
					<th>0.4089</th>
				</tr>
				<tr>
				<tr>
					<th>3</th>
					<th>0.6014</th>
					<th>0.3433</th>
				</tr>
				<tr>
					<th>4</th>
					<th>0.4234</th>
					<th>0.2560</th>
				</tr>
				<tr>
					<th>5</th>
					<th>0.5971</th>
					<th>0.2546</th>
				</tr>
				<tr>
					<th>6</th>
					<th>0.4296</th>
					<th>0.2599</th>
				</tr>
				<tr>
				<tr>
					<th>7</th>
					<th>0.4229</th>
					<th>0.2652</th>
				</tr>
				<tr>
					<th>8</th>
					<th>0.6048</th>
					<th>0.2776</th>
				</tr>
				<tr>
					<th>9</th>
					<th>0.8776</th>
					<th>0.3915</th>
				</tr>
				<tr>
					<th>10</th>
					<th>0.4252</th>
					<th>0.2626</th>
				</tr>
				<tr>
					<th>Average</th>
					<th>0.56252</th>
					<th>0.31581</th>
				</tr>
			</tbody>
		</table>

		<br>

		<table class="styled-table">
			<thead>
				<tr>
					<th></th>
					<th>Timing Results (ms)</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<th>Basic Optimization</th>
					<th>0.56325</th>
				</tr>
				<tr>
					<th>Special Optimization</th>
					<th>0.31581</th>
				</tr>
				<tr>
				<tr>
					<th>Speedup</th>
					<th>1.7835</th>
				</tr>
			</tbody>
		</table>

		<br>

		<p>For speed optimization I used incremental edge evaluation. Instead of recomputing
        \(L_i(x,y)\) from scratch for every pixel, I computed the edge values once at the start of each scanline
        and then incrementally updated them as x increases: \(L_i(x+1,y) = L_i(x,y) + A_i\). 
		This optimization removed repeated multiplies from the inner loop and reduced redundant code.
      	</p>

      	<p>
        To get how much faster the optimized code ran vs the basic one, I measured performance by timing <code>svg.draw(...)</code> inside <code>DrawRend::redraw()</code>
        using the built in clock <code>std::chrono::high_resolution_clock</code>. I ran each version 10 times and took the average and found just by using incremental edge evalution my
		overall performance increasd by a speed of 1.8, almost doubling the performance speed.

		
		<h2>Task 2: Antialiasing by Supersampling</h2>

		<h3>Algorithm</h3>
      	<p>
			I implemented supersampling by rasterizing into a supersample buffer instead of writing directly
			into the final framebuffer. I stored:
		</p>
		<ul>
			<li>
				<code>sample_rate = N</code> sub-samples per pixel.
			</li>
			<li>
				<code>sdim = sqrt(sample_rate)</code>, so each pixel has an <code>sdim × sdim</code> grid of sub-samples.
			</li>
			<li>
				A <code>sample_buffer</code> of size <code>width * height * sample_rate</code>, where each entry stores a color
				for a single sub-sample.
			</li>
		</ul>
		<p>
			Conceptually, all sub-samples for pixel <code>(x, y)</code> are stored contiguously:
		</p>
			<pre>
				<code>
					base = (y * width + x) * sample_rate
				    sample_index = base + s   // s in [0, sample_rate)
			    </code>
			</pre>

		<p>
			I still compute the triangle’s axis-aligned bounding box in pixel coordinates. The difference here is that inside
			the bounding box I test every sub-sample location instead of only the pixel center 
		</p>
		<ol>
			<li>
				I computed and clamped the triangle bounding box to the screen.
			</li>
			<li>
				I then looped over each pixel <code>(x, y)</code> in the bounding box.
			</li>
			<li>
				Then looped over each sub-sample <code>(i, j)</code> in an <code>sdim × sdim</code> grid and evaluate the point:
				<pre>
					<code>
						sx = x + (i + 0.5) / sdim
				        sy = y + (j + 0.5) / sdim
					</code>
				</pre>
			</li>
			<li>
				Then I ran the same point-in-triangle test -edge functions / half-plane tests- at <code>(sx, sy)</code>.
				If inside, write the triangle’s color into the corresponding entry of <code>sample_buffer</code>.
			</li>
		</ol>

		<p>
			For points/lines, I set all sub-samples of the covered pixel to the same color. After rasterizing all 
			primitives into <code>sample_buffer</code>, I computed the final framebuffer color by averaging
			all sub-samples in each pixel:
		<pre>
			<code>
				C(x,y) = (1 / sample_rate) * sum_{s=0..sample_rate-1} C_s(x,y)
			</code>
		</pre>
			This resolving step converts how many sub-samples were inside the triangle into smoother
			pixel intensities.
		</p>

		<h3>Why supersampling is useful</h3>
		<p>
          Supersampling is useful because it reduces aliasing by approximating the true continuous
          area that a triangle covers within each pixel. Instead of a single on&off decision at the pixel center, pixels
          near edges can become partially covered, producing intermediate colors that look a lot smoother.
        </p>
      
      	<h3>Pipeline modifications</h3>
		<p>Compared to the base rasterization pipeline from task 1, I made these changes:
		<ul>
			<li>I asterized into <code>sample_buffer</code>, not directly into the framebuffer.</li>
			<li>Modified triangle rasterization to test and fill multiple sub-samples per pixel.</li>
			<li>Added a final resolve step that averages sub-samples into one framebuffer color per pixel.</li>
			<li>Resized/reinitialized the supersample buffer when the sample rate or viewport size changes.</li>
		</ul>
		</p>

		<h3>How supersampling antialiases triangles</h3>
		<p>
			Triangle edges usually cut through pixels at arbitrary positions. With 1 sample/pixel, edge pixels
			flip abruptly between filled and unfilled. With higher sample rates, only some sub-samples are inside the triangle,
			so the averaged pixel color becomes proportional to coverage. This ultimatley produces a smooth transition along edges instead
			of the staircase pattern from the baseline implementation.
		</p>
		
		<h3>Images</h3>
		<figure>
			<img src="hw1_2_rate1.png" style="width:50%"/>
			<figcaption>Screenshot #4: basic/test4.svg</figcaption>
			<figcaption>sample rate 1</figcaption>
		</figure>
		<figure>
			<img src="hw1_2_rate4.png" style="width:50%"/>
		    <figcaption>Screenshot #5: basic/test4.svg</figcaption>
			<figcaption>sample rate 4</figcaption>
		</figure>
		<figure>
			<img src="hw1_2_rate16.png" style="width:50%"/>
			<figcaption>Screenshot #6: basic/test4.svg</figcaption>
			<figcaption>sample rate 16</figcaption>
		</figure>

		<h3>Extra Credit</h3>
		<p>  
			In addition to standard grid-based supersampling, I implemented a
			jittered sampling pattern. I replaced the fixed <code>0.5</code> offsets with randomized offsets. 
			To keep results stable and to not have flickering across frames, the jitter is
			deterministic so it produces the same jitter pattern every run while still breaking the regular grid structure.
		</p>
		<p>
			The only change for the extra credit is the sampling pattern (grid centers vs jittered offsets). Uniform grid 
			sampling is highly structured, so it can produce coherent aliasing artifacts when
			triangle edges align with the grid (long diagonals, repeated thin triangles, near-parallel edges). In those cases,
			the error can appear as repeating stair-step patterns vs Jittered sampling. As a result Jittered tends to be less 
			structured (more noise-like) and is often less noticeable than repeating jagged edges.
		</p>


		<div class="grid">
			<figure class="ph">
			<div><strong>Grid supersampling (sample rate 1)</strong></div>
			<div style="margin-top: 8px;">
				<img src="hw1_2_ec_notjig.png" style="width:50%"/>
			</div>
			<figcaption>
				Grid sampling can show faint repeating stair-step artifacts due to the periodic sampling lattice.
			</figcaption>
			</figure>

			<figure class="ph">
			<div><strong>Jittered supersampling (same sample rate)</strong></div>
			<div style="margin-top: 8px;">
				<img src="hw1_2_ec_jig.png" style="width:50%"/>
			</div>
			<figcaption>
				Jitter reduces coherent patterns; edges typically look smoother with less structured aliasing.
			</figcaption>
			</figure>
		</div>

		<h2>Task 3: Transforms</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Task 4: Barycentric coordinates</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>(Optional) Task 7: Extra Credit - Draw Something Creative!</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul>
		</div>
	</body>
</html>
